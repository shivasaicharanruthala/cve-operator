/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/google/go-github/v63/github"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"

	processorsv1 "kops.neuadvcloud.xyz/cve-operator/api/v1"
)

// GithubReleasesMonitorReconciler reconciles a GithubReleasesMonitor object
type GithubReleasesMonitorReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=processors.kops.neuadvcloud.xyz,resources=githubreleasesmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=processors.kops.neuadvcloud.xyz,resources=githubreleasesmonitors/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=processors.kops.neuadvcloud.xyz,resources=githubreleasesmonitors/finalizers,verbs=update
// +kubebuilder:rbac:groups=processors.kops.neuadvcloud.xyz,resources=githubreleases,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=processors.kops.neuadvcloud.xyz,resources=githubreleases/status,verbs=get

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the GithubReleasesMonitor object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.18.4/pkg/reconcile
func (r *GithubReleasesMonitorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	
	log.SetLogger(zap.New())

	log := log.Log.WithName("controllers").WithName("GithubRelease")

	var monitor processorsv1.GithubReleasesMonitor

	if err := r.Get(ctx, req.NamespacedName, &monitor); err != nil {
		log.Error(err, "unable to fetch GithubReleasesMonitor")
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	var childReleases processorsv1.GithubReleaseList

	if err := r.List(ctx, &childReleases, client.InNamespace(req.Namespace), client.MatchingFields{"metadata.owner": req.Name}); err != nil {
		log.Error(err, "unable to list child GithubReleases")
		return ctrl.Result{}, err
	}

	activeGithubReleases := make(map[string]*processorsv1.GithubRelease, 0)
	mostRecentProcessedReleasePublishTime := time.Time{}

	for i, release := range childReleases.Items {
		activeGithubReleases[release.GetName()] = &childReleases.Items[i]

		if mostRecentProcessedReleasePublishTime.IsZero() || mostRecentProcessedReleasePublishTime.Before(release.Spec.ReleaseTime.Time) {
			mostRecentProcessedReleasePublishTime = release.Spec.ReleaseTime.Time
		}
	}

	if !mostRecentProcessedReleasePublishTime.IsZero() {
		monitor.Status.LastProcessedReleaseTime = &metav1.Time{Time: mostRecentProcessedReleasePublishTime}
	} else {
		monitor.Status.LastProcessedReleaseTime = nil
	}

	if monitor.Status.MonitorFromTime == nil {
		if monitor.Spec.MonitorFrom == "now" {
			monitor.Status.MonitorFromTime = &metav1.Time{Time: time.Now()}
		} else {
			monitorFromTime, err := time.Parse(time.RFC3339, monitor.Spec.MonitorFrom)
			if err != nil {
				log.Error(err, "unable to parse monitor from time")
				return ctrl.Result{}, err
			}
			monitor.Status.MonitorFromTime = &metav1.Time{Time: monitorFromTime}
		}
	}

	constructGithubReleaseForMonitor := func(monitor *processorsv1.GithubReleasesMonitor, nextPublishReleaseTime time.Time, assetDownloadUrl string) (*processorsv1.GithubRelease, error) {

		name := fmt.Sprintf("githubrelease-%d", nextPublishReleaseTime.Unix())
		githubRelease := &processorsv1.GithubRelease{
			ObjectMeta: metav1.ObjectMeta{
				Name:        name,
				Labels:      make(map[string]string),
				Annotations: make(map[string]string),
				Namespace:   monitor.Namespace,
				OwnerReferences: []metav1.OwnerReference{
					{
						APIVersion: monitor.APIVersion,
						Kind:       monitor.Kind,
						Name:       monitor.Name,
						UID:        monitor.UID,
					},
				},
			},
			Spec: processorsv1.GithubReleaseSpec{
				URL:         assetDownloadUrl,
				ReleaseTime: metav1.Time{Time: nextPublishReleaseTime},
				JobTemplate: monitor.Spec.JobTemplate,
			},
		}

		for k, v := range monitor.Annotations {
			githubRelease.Annotations[k] = v
		}

		if err := ctrl.SetControllerReference(monitor, githubRelease, r.Scheme); err != nil {
			return nil, err
		}

		return githubRelease, nil
	}

	for releaseName, releaseInStatus := range monitor.Status.OwnedGithubReleases {
		if _, ok := activeGithubReleases[releaseName]; !ok {
			githubRelease, err := constructGithubReleaseForMonitor(&monitor, releaseInStatus.Spec.ReleaseTime.Time, releaseInStatus.Spec.URL)
			if err != nil {
				log.Info("unable to construct deleted GithubRelease", "error", err)
			} else {
				if err := r.Create(ctx, githubRelease); err != nil {
					log.Info("unable to create new GithubRelease", "err", err, "githubrelease", githubRelease)
				} else {
					if monitor.Status.LastProcessedReleaseTime == nil || monitor.Status.LastProcessedReleaseTime.Time.Before(githubRelease.Spec.ReleaseTime.Time) {
						monitor.Status.LastProcessedReleaseTime = &metav1.Time{Time: githubRelease.Spec.ReleaseTime.Time}
					}
					log.V(1).Info("Created GithubRelease for GithubReleasesMonitor", "githubrelease", githubRelease)
				}
			}
		}
	}

	monitor.Status.OwnedGithubReleases = activeGithubReleases

	log.V(1).Info("githubreleases count", "total githubreleases for this monitor", len(activeGithubReleases))

	if err := r.Status().Update(ctx, &monitor); err != nil {
		log.Error(err, "unable to update GithubReleasesMonitor status")
		return ctrl.Result{}, err
	}

	getNextGithubReleaseToBeProcessed := func(monitor *processorsv1.GithubReleasesMonitor, now time.Time) (time.Time, string, error) {

		var lastProcessedTime time.Time
		if monitor.Status.LastProcessedReleaseTime == nil {
			lastProcessedTime = monitor.Status.MonitorFromTime.Time
		} else {
			lastProcessedTime = monitor.Status.LastProcessedReleaseTime.Time
		}

		githubClient := github.NewClient(nil)

		lastProcessedTime = lastProcessedTime.UTC()
		now = now.UTC()

		if monitor.Status.LastProcessedReleaseTime != nil && lastProcessedTime.Add(time.Hour*1).After(now) {
			log.V(1).Info("last processed release is less than an hour old")
			return time.Time{}, "", nil
		}

		finalReleases := make([]*github.RepositoryRelease, 0)

		for i := 1; ; i++ {
			releases, _, err := githubClient.Repositories.ListReleases(context.Background(), "CVEProject", "cvelistV5", &github.ListOptions{
				PerPage: 100,
				Page:    i,
			})

			if err != nil {
				return time.Time{}, "", err
			}

			if len(releases) == 0 {
				break
			}

			foundOlderRelease := false
			for _, release := range releases {

				if release.GetPublishedAt().Time.Before(lastProcessedTime) || release.GetPublishedAt().Time.Equal(lastProcessedTime) {
					foundOlderRelease = true
					break
				}
				finalReleases = append(finalReleases, release)
			}

			if foundOlderRelease {
				break
			}

		}

		if len(finalReleases) == 0 {
			log.V(1).Info("no suitable release found for processing")
			return time.Time{}, "", nil
		}

		monitor.Status.LatestRetrievedTime = &metav1.Time{Time: now}
		validReleaseNames := make([]string, 0)

		for _, release := range finalReleases {
			validReleaseNames = append(validReleaseNames, release.GetName())
		}

		monitor.Status.ReleaseNamesFromRepositories = validReleaseNames

		if err := r.Status().Update(ctx, monitor); err != nil {
			log.Error(err, "unable to update GithubReleasesMonitor status")
			return time.Time{}, "", err
		}

		assetFound := false
		assetDownloadUrl := ""
		releaseTime := time.Time{}

		for i := len(finalReleases) - 1; i >= 0; i-- {
			for _, asset := range finalReleases[i].Assets {
				if strings.Contains(asset.GetName(), "delta") {
					assetFound = true
					assetDownloadUrl = asset.GetBrowserDownloadURL()
					releaseTime = finalReleases[i].GetPublishedAt().Time
				}
			}
			if assetFound {
				break
			}
		}

		if !assetFound {
			log.V(1).Info("no asset found for processing")
			return time.Time{}, "", nil
		} else {
			return releaseTime, assetDownloadUrl, nil
		}

	}

	nextPublishReleaseTime, assetDownloadUrl, err := getNextGithubReleaseToBeProcessed(&monitor, time.Now())

	if err != nil {
		log.Error(err, "error getting a new time for publishing")
		return ctrl.Result{}, err
	}

	if nextPublishReleaseTime.IsZero() {
		log.V(1).Info("no new release to process")
		return ctrl.Result{RequeueAfter: time.Minute * 1}, nil
	}

	newGithubRelease, err := constructGithubReleaseForMonitor(&monitor, nextPublishReleaseTime, assetDownloadUrl)

	if err != nil {
		log.Error(err, "unable to construct new GithubRelease")
		return ctrl.Result{}, err
	}

	if err := r.Create(ctx, newGithubRelease); err != nil {
		log.Error(err, "unable to create new GithubRelease", "githubrelease", newGithubRelease)
		return ctrl.Result{}, err
	}

	log.V(1).Info("Created GithubRelease for GithubReleasesMonitor", "githubrelease", newGithubRelease)

	return ctrl.Result{Requeue: true}, nil
}

// SetupWithManager sets up the controller with the Manager.
func (r *GithubReleasesMonitorReconciler) SetupWithManager(mgr ctrl.Manager) error {

	if err := mgr.GetFieldIndexer().IndexField(context.Background(), &processorsv1.GithubRelease{}, "metadata.owner", func(rawObj client.Object) []string {
		// grab the job object, extract the owner...
		job := rawObj.(*processorsv1.GithubRelease)
		owner := metav1.GetControllerOf(job)
		if owner == nil {
			return nil
		}
		// ...make sure it's a GithubReleasesMonitor...
		if owner.APIVersion != processorsv1.GroupVersion.String() || owner.Kind != "GithubReleasesMonitor" {
			return nil
		}

		// ...and if so, return it
		return []string{owner.Name}
	}); err != nil {
		return err
	}
	return ctrl.NewControllerManagedBy(mgr).
		For(&processorsv1.GithubReleasesMonitor{}).
		Owns(&processorsv1.GithubRelease{}).
		Complete(r)
}
